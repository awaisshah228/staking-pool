const axios = require("axios");

const verifyContract = async (_verifyParameters) => {
    const baseUrlApi = "https://volta-explorer.energyweb.org/api/";
    
   return (await axios({
       method: 'post',
       url:`${baseUrlApi}`,
       data: _verifyParameters,
    }));
}

const verifyParameters = {
    module: "contract",
    action: "verify",
    addressHash: "0x3490B3e5E7C1f696c61FDe1c2679725B19274B0e",
    name: "StakingPool",
    compilerVersion: "0.8.6+commit.11564f7e",
    optimization: false,
    contractSourceCode: "//SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./libs/ABDKMath64x64.sol\";\n\ncontract StakingPool {\n    using ABDKMath64x64 for int128;\n\n    address public owner;\n    address public claimManager;\n    uint256 public start;\n    uint256 public end;\n    uint256 public ratio;\n    uint256 public hardCap;\n    uint256 public contributionLimit;\n    uint256 public totalStaked;\n\n    struct Stake {\n        uint256 stake;\n        uint256 compounded;\n        uint256 time;\n    }\n\n    event StakeAdded(address indexed sender, uint256 amount, uint256 time);\n    event StakeWithdrawn(address indexed sender, uint256 amount);\n    event StakingPoolInitialized(uint256 funded, uint256 indexed timestamp);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    mapping(address => Stake) public stakes;\n    modifier onlyOwner(){\n        require(msg.sender == owner, \"OnlyOwner: Not authorized\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        //check if appropraite role\n        // check if deposit is at least the max rewards\n        // require(calculateReward(_end - _start, _hardCap) <= msg.value);\n    }\n\n    function init(\n        address _claimManager,\n        uint256 _start,\n        uint256 _end,\n        uint256 _ratio,\n        uint256 _hardCap,\n        uint256 _contributionLimit\n    ) external payable onlyOwner {\n        uint256 timestamp = block.timestamp;\n        require(\n            _start >= timestamp,\n            \"Start date should be at least current block timestamp\"\n        );\n        // check if stake pool time is at least 1 day\n        require(_end - _start >= 1 days, \"Duration should be at least 1 day\");\n        require(msg.value > 0, \"Staking pool should be funded\");\n\n        claimManager = _claimManager;\n        start = _start;\n        end = _end;\n        ratio = _ratio;\n        hardCap = _hardCap;\n        contributionLimit = _contributionLimit;\n        \n        emit StakingPoolInitialized(msg.value, timestamp);\n    }\n\n    function changeOwner(address _newOwner) external onlyOwner {\n        require(owner != _newOwner, \"changeOwner: already owner\");\n        address oldOwner = owner;\n        owner = _newOwner;\n        emit OwnershipTransferred(oldOwner, _newOwner);\n    }\n\n    function stake() public payable {\n        // check role with claimManager\n        require(start != 0, \"Staking Pool not initialized\");\n        require(block.timestamp >= start, \"Staking pool not yet started\");\n        require(block.timestamp <= end, \"Staking pool already expired\");\n\n        require(\n            stakes[msg.sender].stake + msg.value <= contributionLimit,\n            \"Stake greater than contribution limit\"\n        );\n\n        require(hardCap - totalStaked >= msg.value, \"Staking pool is full\");\n\n        (, uint256 compounded) = total();\n\n        // track user stake\n        stakes[msg.sender].stake += msg.value;\n        // store compounded value\n        stakes[msg.sender].compounded = compounded + msg.value;\n        // update compunding time\n        stakes[msg.sender].time = block.timestamp;\n\n        totalStaked += msg.value;\n\n        emit StakeAdded(msg.sender, msg.value, block.timestamp);\n    }\n\n    //allow specifing the value\n    function unstakeAll() public {\n        (, uint256 payout) = total();\n\n        require(payout > 0, \"No stake available\");\n\n        totalStaked -= stakes[msg.sender].stake;\n        delete stakes[msg.sender];\n        payable(msg.sender).transfer(payout);\n\n        emit StakeWithdrawn(msg.sender, payout);\n    }\n\n    function total() public view returns (uint256, uint256) {\n        Stake memory senderStake = stakes[msg.sender];\n\n        // checks if there is no stake added\n        if (senderStake.time == 0) {\n            return (0, 0);\n        }\n\n        uint256 compoundEnd = block.timestamp;\n\n        if (block.timestamp > end) {\n            compoundEnd = end;\n        }\n\n        uint256 period = compoundEnd - senderStake.time;\n        uint256 periods = period / 1 hours;\n\n        uint256 compounded = compound(senderStake.compounded, ratio, periods);\n\n        return (senderStake.stake, compounded);\n    }\n\n    function compound(\n        uint256 principal,\n        uint256 _ratio,\n        uint256 n\n    ) public pure returns (uint256) {\n        return\n            ABDKMath64x64.mulu(\n                ABDKMath64x64.pow(\n                    ABDKMath64x64.add(\n                        ABDKMath64x64.fromUInt(1),\n                        ABDKMath64x64.divu(_ratio, 10**18)\n                    ),\n                    n\n                ),\n                principal\n            );\n    }\n}\n"
};

(async function verify(){
   console.log("Verified .. ", await verifyContract(verifyParameters));
})()